"""
Module for constructing and matching undulator wigglers.

This module provides functions to:
- Load and process fit_parameters.csv
- Construct piecewise wiggler from SplineBoris elements
- Match wiggler with correction elements
- Create both standard and offset wiggler lines
"""

import xtrack as xt
import numpy as np
import pandas as pd
from pathlib import Path


def _contruct_par_table(n_steps, s_start, s_end, df_flat, multipole_order):
    """
    Construct parameter table for SplineBoris.
    
    Parameters are ordered as expected by the C code:
    - For multipole_order=3: bs_*, kn_1_*, kn_2_*, kn_3_*, ks_1_*, ks_2_*, ks_3_*
    - Within each group: ordered by polynomial order (0, 1, 2, 3, 4)
    - kn_* (normal multipole) and ks_* (skew multipole)
    """
    par_dicts = []
    par_table = []
    s_vals = np.linspace(float(s_start), float(s_end), n_steps)
    
    # Expected parameter order for the given multipole_order
    # C code expects parameters in SORTED order (alphabetically)
    # This matches the order generated by _generate_bpmeth_to_C.py param_names_list()
    # Order: bs_*, then for each multipole: ks_*, kn_* (interleaved), then bs_* only for first multipole
    # After sorting: bs_0..bs_4, kn_1_0..kn_1_4, kn_2_0..kn_2_4, kn_3_0..kn_3_4, ks_1_0..ks_1_4, ks_2_0..ks_2_4, ks_3_0..ks_3_4
    expected_params = []
    # Build in the same order as _generate_bpmeth_to_C.py param_names_list() which sorts them
    # First: bs_ parameters (only for first multipole, but we include them first)
    for poly_idx in range(5):
        expected_params.append(f"bs_{poly_idx}")
    # Then: kn_ parameters (all multipoles) - normal multipole
    for multipole_idx in range(1, multipole_order + 1):
        for poly_idx in range(5):  # 0 to 4
            expected_params.append(f"kn_{multipole_idx}_{poly_idx}")
    # Finally: ks_ parameters (all multipoles) - skew multipole
    for multipole_idx in range(1, multipole_order + 1):
        for poly_idx in range(5):  # 0 to 4
            expected_params.append(f"ks_{multipole_idx}_{poly_idx}")
    # Note: This order matches the sorted order from param_names_list() because:
    # - 'bs_' < 'kn_' < 'ks_' alphabetically
    # - Within each group, numbers sort correctly (1 < 2 < 3, 0 < 1 < 2 < 3 < 4)
    
    for s_val_i in s_vals:
        # Filter rows that contain this s position
        # The field fitter stores parameters with different derivative_x values:
        # - derivative_x=0 → ks_1_*, kn_1_* (first multipole order)
        # - derivative_x=1 → ks_2_*, kn_2_* (second multipole order)
        # - derivative_x=2 → ks_3_*, kn_3_* (third multipole order)
        # We need to read ALL derivative_x values to get all multipole orders
        mask = ((df_flat['s_start'] <= s_val_i) & 
                (df_flat['s_end'] >= s_val_i))
        rows = df_flat[mask]
        
        # Create a dictionary from available parameters
        # Group by field_component to ensure we get all parameters from the same region
        # when possible, but allow different regions for different field components
        param_dict = {}
        if not rows.empty:
            # Sort by field_component and region to ensure consistent selection
            # when there are multiple matches, prefer the most specific region (smallest s range)
            rows_sorted = rows.copy()
            rows_sorted['region_size'] = rows_sorted['s_end'] - rows_sorted['s_start']
            rows_sorted = rows_sorted.sort_values(['field_component', 'region_size', 'param_name'])
            
            # Take the first occurrence of each param_name (should be from the smallest region)
            for _, row in rows_sorted.iterrows():
                param_name = row['param_name']
                if param_name not in param_dict:
                    param_dict[param_name] = row['param_value']
        
        # Build parameter list in expected order, filling missing values with 0
        param_values = []
        for param_name in expected_params:
            if param_name in param_dict:
                param_values.append(float(param_dict[param_name]))
            else:
                param_values.append(0.0)  # Fill missing parameters with 0
        
        par_dicts.append(param_dict)
        par_table.append(param_values)
    
    return par_dicts, par_table
